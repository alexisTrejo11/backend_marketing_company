# COMMON TYPES
type PaginationMetadata {
    currentPage: Int!
    pageSize: Int!
    total: Int!
    totalPages: Int!
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
}

interface PageResponse {
    pagination: PaginationMetadata!
}

# Account Management
# Auth
input SignUpInput {
    email: String!
    password: String!
    firstName: String!
    lastName: String!
    phoneNumber: String
}

input LoginInput {
    email: String!
    password: String!
}


input RefreshTokenInput {
    refreshToken: String!
}

type AuthResponse {
    accessToken: String,
    refreshToken: String,
    accessTokenExpiresAt: DateTime,
    refreshTokenExpiresAt: DateTime,
    user: User
}

# USERS
type User {
    id: ID
    username: String
    email: String
    role: UserRole
}

input UserInput {
    username: String!
    email: String
    password: String!
    role: UserRole!
}
enum UserRole {
    ADMIN
    SALES_MANAGER,
    SALES_REP
}


# CompanyResponse CompanyResponse
enum CompanySize {
    SMALL
    MEDIUM
    LARGE
    ENTERPRISE
}

enum CompanyStatus {
    PROSPECT,
    LEAD,
    ACTIVE,
    INACTIVE,
    CHURNED,
    BLOCKED,
    PARTNER,
    UNKNOWN
}

enum ContractType {
    MONTHLY
    ANNUAL
    TRIAL
}

type CompanyPageResponse implements PageResponse {
    items: [CompanyResponse!]!
    pagination: PaginationMetadata!
}


type CompanyResponse {
    id: ID!
    companyName: String!
    legalName: String
    taxId: String
    website: String
    foundingYear: Int

    industry: IndustryResponse
    size: CompanySize
    employeeCount: Int
    annualRevenue: RevenueResponse

    status: CompanyStatus!
    isPublicCompany: Boolean
    isStartup: Boolean

    targetMarket: String
    missionStatement: String
    keyProducts: [String]
    competitorUrls: [String]

    contactPersons: [ContactPersonResponse]
    contractDetails: ContractDetailsResponse
    billingInfo: BillingInfoResponse
    socialMedia: SocialMediaResponse

    opportunityCount: Int
    interactionCount: Int

    createdAt: DateTime
    updatedAt: DateTime
}

type IndustryResponse {
    code: String
    name: String
    sector: String
}

type RevenueResponse {
    amount: Float
    currency: String
    range: String
}

type ContactPersonResponse {
    id: ID!
    firstName: String
    lastName: String
    email: String
    phone: String
    position: String
    department: String
    isDecisionMaker: Boolean
    isPrimaryContact: Boolean!
}

type ContractDetailsResponse {
    contractId: String
    startDate: Date
    endDate: Date
    monthlyFee: Float
    type: String
    autoRenewal: Boolean
    isActive: Boolean
    isExpiringSoon: Boolean
}

type BillingInfoResponse {
    billingEmail: String
    preferredPaymentMethod: String
    billingAddress: String
    approvedCredit: Boolean
}

type SocialMediaResponse {
    linkedinUrl: String
    twitterHandle: String
    facebookUrl: String
    instagramHandle: String
}

type CompanyMetrics {
    companyId: ID!
    opportunityCount: Int
    interactionCount: Int
    activeContracts: Int
    revenueEstimate: RevenueResponse
}

input ContactPersonInput {
    firstName: String!
    lastName: String!
    email: String
    phone: String
    position: String
    department: String
    isDecisionMaker: Boolean = false
    isPrimaryContact: Boolean = false
}

input CreateCompanyInput {
    companyName: String
    industry: String
    companySize: CompanySize
    employeeCount: Int
    foundingYear: Int
    missionStatement: String
    targetMarket: String
    contactPersons: [ContactPersonInput!]
    taxId: String
    website: String
    keyProducts: [String!]!
}

input UpdateCompanyProfileInput {
    industryCode: String!
    employeeCount: Int
    missionStatement: String
    targetMarket: String
    keyProducts: [String!]
    competitorUrls: [String!]
    socialMediaHandles: SocialMediaInput
    foundingYear: Int
}

input UpdateCompanyBillingInput {
    taxId: String!
    billingEmail: String
    paymentMethod: String
    billingAddress: String
    approvedCredit: Boolean = false
}

input UpdateCompanyInput {
    id: ID!
    companyName: String
    profileCommand: UpdateCompanyProfileInput
    billingCommand: UpdateCompanyBillingInput
}

input BlockCompanyInput {
    id: ID!
    reason: String!
}

input DeactivateCompanyInput {
    id: ID!
    reason: String
}

input UpgradeToEnterpriseInput {
    id: ID!
    annualRevenue: BigDecimal!
    currency: String
}

input SignContractInput {
    id: ID!
    contractId: String!
    monthlyFee: BigDecimal!
    contractType: ContractType!
    durationMonths: Int
    autoRenewal: Boolean = false
}

input AddContactPersonInput {
    companyId: ID!
    firstName: String!
    lastName: String!
    email: String
    phone: String
    position: String
    department: String
    isDecisionMaker: Boolean = false
}

input SocialMediaInput {
    linkedinUrl: String
    twitterHandle: String
    facebookUrl: String
    instagramHandle: String
}



# Opportunity
type Opportunity {
    id: ID!
    customerCompanyId: ID!
    CompanyResponse: CustomerInfo!
    title: String!
    amount: Float
    stage: OpportunityStage!
    expectedCloseDate: String
    isClosed: Boolean!
    isWon: Boolean!
    isLost: Boolean!
    isOverdue: Boolean!
    canBeModified: Boolean!
    createdAt: String!
    updatedAt: String!
}
type OpportunityStatistics {
    totalOpportunities: Int!
    activeOpportunities: Int!
    wonOpportunities: Int!
    lostOpportunities: Int!
    winRate: Float!
}

# Input Types
input CreateOpportunityInput {
    customerCompanyId: ID!
    title: String!
    amount: Float
    expectedCloseDate: String
}

input UpdateOpportunityInput {
    opportunityId: ID!
    title: String!
    amount: Float
    expectedCloseDate: String
}

input OpportunityFilterInput {
    searchTerm: String
    stages: [OpportunityStage!]
    customerCompanyId: ID
}

# Enums
enum OpportunityStage {
    LEAD
    QUALIFIED
    PROPOSAL
    NEGOTIATION
    CLOSED_WON
    CLOSED_LOST
}



# TaskEntity
enum TaskStatus {
    PENDING
    IN_PROGRESS
    COMPLETED
}
enum TaskPriority {
    HIGH
    MEDIUM
    LOW
}

type Task {
    id: ID!
    customerCompany: CompanyResponse!
    opportunity: Opportunity!
    title: String!
    description: String
    dueDate: String!
    status: TaskStatus!
    priority: TaskPriority!
    assignedTo: User
}
input TaskInput {
    customerCompanyId: ID!
    opportunityId: ID!
    title: String!
    description: String
    dueDate: String!
    status: TaskStatus!
    priority: TaskPriority!
    assignedToUserId: ID
}



#Service Package
enum ServiceType {
    SOCIAL_MEDIA,
    SEO,
    PPC,
    CONTENT,
    EMAIL,
    BRANDING
}

enum Complexity {
    BASIC,
    STANDARD,
    PREMIUM
}
enum Frequency {
    DAILY
    WEEKLY
    MONTHLY
    ANNUALLY
}
enum SocialNetworkPlatform {
    FACEBOOK
    INSTAGRAM
    TWITTER
    LINKEDIN
    TIKTOK
}
type ServicePackage {
    id: ID!
    name: String!
    description: String
    price: Float!
    serviceType: ServiceType!
    deliverables: String
    estimatedHours: Int!
    complexity: Complexity!
    isRecurring: Boolean!
    frequency: Frequency
    projectDuration: Int
    kpis: [String!]!
    socialNetworkPlatforms: [SocialNetworkPlatform!]!
    active: Boolean!
    createdAt: String!
    updatedAt: String!
}
input ServicePackageInput {
    name: String!
    description: String
    price: Float!
    serviceType: ServiceType!
    deliverables: String
    estimatedHours: Int!
    complexity: Complexity!
    isRecurring: Boolean!
    frequency: Frequency
    projectDuration: Int
    kpis: [String!]!
    socialNetworkPlatforms: [SocialNetworkPlatform!]!
    active: Boolean!
}

# QuoteEntity
type Quote {
    id: ID!
    customerCompany: CompanyResponse!
    opportunity: Opportunity
    validUntil: String!
    subTotal: Float!
    discount: Float!
    totalAmount: Float!
    status: QuoteStatus!
    items: [QuoteItem!]!
    createdAt: String!
    updatedAt: String!
}
input QuoteInput {
    customerCompanyId: ID!
    opportunityId: ID!
    validUntil: String!
    status: QuoteStatus!
    items: [QuoteItemInput!]!
}
# QuoteEntity Item
type QuoteItem {
    id: ID!
    quoteEntity: Quote!
    servicePackageEntity: ServicePackage!
    unitPrice: Float!
    total: Float!
    discountPercentage: Float!
    discount: Float!
}
input QuoteItemInput {
    servicePackageId: ID!
    discountPercentage: Float!
}
enum QuoteStatus {
    DRAFT
    SENT
    ACCEPTED
    REJECTED
}


# Interaction
type Interaction {
    id: ID!
    customerCompany: CompanyResponse!
    type: InteractionType!
    dateTime: String!
    description: String
    outcome: String!
    feedbackType: FeedbackType
    channelPreference: String
    createdAt: String!
    updatedAt: String!
}
input InteractionInput {
    customerCompanyId: ID!
    type: InteractionType!
    dateTime: String!
    description: String
    outcome: String!
    feedbackType: FeedbackType
    channelPreference: String
}
enum InteractionType {
    EMAIL
    CALL
    MEETING
    NOTE
}

enum FeedbackType {
    CONTENT_REVIEW
    CAMPAIGN_PERFORMANCE
    STRATEGY
}


# Deals
type Deal {
    id: ID!
    customerCompanyId: ID!
    CompanyResponse: CustomerInfo!
    opportunityId: ID!
    opportunity: OpportunityInfo!
    dealStatus: String!
    finalAmount: Float
    startDate: String!
    endDate: String
    campaignManagerId: ID
    campaignManager: UserInfo
    services: [ServicePackageInfo!]!
    deliverables: String
    terms: String
    createdAt: String!
    updatedAt: String!
}

# Types para nested objects
type CustomerInfo {
    id: ID!
    name: String!
    email: String!
}

type OpportunityInfo {
    id: ID!
    title: String!
    stage: String!
}

type UserInfo {
    id: ID!
    name: String!
    email: String!
}

type ServicePackageInfo {
    id: ID!
    name: String!
    description: String!
}

# Input Types
input CreateDealInput {
    opportunityId: ID!
    servicePackageIds: [ID!]!
    startDate: String!
}

input SignDealInput {
    dealId: ID!
    finalAmount: Float!
    terms: String!
    campaignManagerId: ID!
}

input CompleteDealInput {
    dealId: ID!
    endDate: String!
    deliverables: String!
}

input UpdateDealServicesInput {
    dealId: ID!
    servicePackageIds: [ID!]!
}

input DealFilterInput {
    statuses: [String!]
    customerCompanyId: ID
    campaignManagerId: ID
    startDate: String
    endDate: String
}

type Property {
    key: String!
    value: String!
}

input PropertyInput {
    key: String!
    value: String!
}



# MARKETING #
# Type for CampaignActivityModel
scalar JSON
scalar DateTime
scalar Date
scalar BigDecimal

type CampaignActivity {
    id: ID
    name: String
    description: String
    activityType: ActivityType
    plannedStartDate: DateTime
    plannedEndDate: DateTime
    actualStartDate: DateTime
    actualEndDate: DateTime
    status: ActivityStatus
    plannedCost: BigDecimal
    actualCost: BigDecimal
    assignedTo: String
    successCriteria: String
    targetAudience: String
    deliveryChannel: String
}

# Input for creating a new CampaignActivityModel
input CampaignActivityInput {
    name: String!
    description: String
    activityType: ActivityType!
    plannedStartDate: DateTime!
    plannedEndDate: DateTime!
    plannedCost: BigDecimal
    successCriteria: String
    targetAudience: String
    deliveryChannel: String
    campaignId: ID!
}


# Enum for ActivityType
enum ActivityType {
    ADVERTISEMENT
    EMAIL_CAMPAIGN
    SOCIAL_MEDIA_POST
    EVENT
    OTHER
}

# Enum for ActivityStatus
enum ActivityStatus {
    PLANNED
    IN_PROGRESS
    COMPLETED
    CANCELLED
}

# Type for CampaignAttributionModel
type CampaignAttribution {
    id: ID
    dealId: ID
    campaignId: ID
    attributionModel: AttributionModel!
    attributionPercentage: BigDecimal
    attributedRevenue: BigDecimal
    firstTouchDate: DateTime
    lastTouchDate: DateTime
    touchCount: Int
    distribution: [CampaignAttribution]
}

# Input for creating a new CampaignAttributionModel
input CampaignAttributionInput {
    dealId: ID!
    campaignId: ID!
    attributionModel: AttributionModel!
    attributionPercentage: BigDecimal
    attributedRevenue: BigDecimal
    touchCount: Int
}

# Enum for AttributionModel
enum AttributionModel {
    FIRST_TOUCH,
    LAST_TOUCH,
    LINEAR,
    U_SHAPED,
    W_SHAPED,
    TIME_DECAY,
    POSITION_BASED,
    CUSTOM
}

# Type for CampaignInteractionModel
type CampaignInteraction {
    id: ID
    campaignId: ID
    customerCompanyId: ID
    interactionType: MarketingInteractionType
    sourceChannel: String
    sourceMedium: String
    sourceCampaign: String
    deviceType: String
    ipAddress: String
    geoLocation: String
    properties: JSON
    details: String
    resultedDealId: ID
    conversionValue: Float
}


# Input for creating a new CampaignInteractionModel
input CampaignInteractionInput {
    campaignId: ID
    customerCompanyId: ID
    interactionType: MarketingInteractionType
    interactionDate: String
    sourceChannel: String
    sourceMedium: String
    sourceCampaign: String
    deviceType: String
    ipAddress: String
    geoLocation: String
    properties: JSON
    details: String
    resultedDealId: ID
    conversionValue: Float
}

# Enum for MarketingInteractionType
enum MarketingInteractionType {
    EMAIL_SENT,
    EMAIL_OPENED,
    EMAIL_CLICKED,
    FORM_SUBMISSION,
    WEBSITE_VISIT,
    PAGE_VIEW,
    CONTENT_DOWNLOAD,
    VIDEO_VIEW,
    SOCIAL_ENGAGEMENT,
    SOCIAL_SHARE,
    SOCIAL_COMMENT,
    SOCIAL_LIKE,
    EVENT_REGISTRATION,
    EVENT_ATTENDANCE,
    WEBINAR_REGISTRATION,
    WEBINAR_ATTENDANCE,
    AD_IMPRESSION,
    AD_CLICK,
    APP_INSTALLED,
    APP_OPENED,
    PURCHASE,
    CART_ABANDONED,
    LEAD_CREATED,
    OPPORTUNITY_CREATED,
    DEAL_CLOSED,
    CALL_SCHEDULED,
    CALL_COMPLETED,
    MEETING_SCHEDULED,
    MEETING_COMPLETED,
    DIRECT_MESSAGE,
    SURVEY_COMPLETED,
    REVIEW_SUBMITTED,
    REFERRAL_SENT,
    REFERRAL_CONVERTED,
    CUSTOM
}

# Type for CustomerSegment
type CustomerSegment {
    id: ID!
    name: String!
    description: String
    segmentCriteria: String
    dynamic: Boolean!
    rules: JSON
    campaignIds: [ID!]
    customerIds: [ID!]
    lastUpdated: String
}

# Input for creating a new CustomerSegment
input CustomerSegmentInput {
    name: String!
    description: String
    segmentCriteria: String
    dynamic: Boolean
    rules: JSON
}


# Type for CampaignMetricModel
type CampaignMetric {
    id: ID
    campaignId: ID
    name: String
    description: String
    type: MetricType
    value: BigDecimal
    targetValue: BigDecimal
    measurementUnit: String
    lastCalculated: DateTime
    calculationFormula: String
    dataSource: String
    automated: Boolean
}

# Input for creating a new CampaignMetricModel
input CampaignMetricInput {
    campaignId: ID
    name: String
    description: String
    type: MetricType
    value: BigDecimal
    targetValue: BigDecimal
    measurementUnit: String
    calculationFormula: String
    dataSource: String
    automated: Boolean
}

# Enum for MetricType
enum MetricType {
    COUNT,
    PERCENTAGE,
    CURRENCY,
    RATIO,
    DURATION,
    COST,
    SCORE,
    CUSTOM
}

# Type for MarketingCampaign
type MarketingCampaign {
    id: ID!
    name: String!
    description: String
    startDate: Date
    endDate: Date
    budget: BigDecimal
    costToDate: BigDecimal
    status: CampaignStatus!
    type: CampaignType!
    targetAudience: String
    successCriteria: String
    targets: JSON
    relatedDealIds: [ID]
    targetSegmentIds: [ID]
}

# Input for creating a new MarketingCampaign
input MarketingCampaignInput {
    name: String!
    description: String
    startDate: Date!
    endDate: Date
    budget: BigDecimal
    targetAudience: TargetAudienceDetailsInput
    successCriteria: SuccessCriteriaDetailsInput
    targets: JSON
    type: CampaignType!
}

input TargetAudienceDetailsInput {
    description: String!
    demographics: [String!]!
    geographicLocations: [String!]!
    interests: [String!]!
}

input SuccessCriteriaDetailsInput {
    description: String!
    metrics: [MetricInput!]!
}

input MetricInput {
    name: String!
    value: Float!
}


# Enum for CampaignStatus
enum CampaignStatus {
    DRAFT
    PLANNED
    APPROVED
    SCHEDULED
    ACTIVE
    PAUSED
    COMPLETED
    CANCELLED
    ANALYZING
}

# Enum for CampaignType
enum CampaignType {
    EMAIL
    SOCIAL_MEDIA
    CONTENT_MARKETING
    EVENT
    WEBINAR
    PPC
    SEO
    DIRECT_MAIL
    SMS
    REFERRAL
    AFFILIATE
    INFLUENCER
    PR
    TRADE_SHOW
    PRINT
    TV
    RADIO
    REMARKETING
    MULTI_CHANNEL
    OTHER
}


input PageInput {
    page: Int = 0
    size: Int = 10
    sortBy: String = "createdAt"
    ascending: Boolean = false
}

# Queries
type Query {
    #CRM
    getAllUsers(input: PageInput): [User!]!
    getUserById(id: ID!): User

    # Customer Company
    getAllCompanies(pageInput: PageInput): CompanyPageResponse!
    getCompanyById(id: ID!): CompanyResponse
    searchCompanies(searchTerm: String, pageInput: PageInput): [CompanyResponse!]!
    getCompaniesByIndustry(industryCode: String!): [CompanyResponse!]!
    getCompaniesByStatus(status: CompanyStatus): [CompanyResponse!]!
    getHighValueCompanies(minRevenue: BigDecimal!): [CompanyResponse!]!
    getStartups(startYearSince: Int!): [CompanyResponse!]!
    getCompaniesWithExpiringContracts(daysThreshold: Int): [CompanyResponse!]!
    isCompanyActive(id: ID!): Boolean!
    hasActiveContract(id: ID!): Boolean!
    getCompanyMetrics(companyId: ID!): CompanyMetrics

    # Opportunities
    getAllOpportunities(input: PageInput): [Opportunity!]!
    getOpportunityById(id: ID!): Opportunity

    getAllTasks(input: TaskInput!): [Task!]!
    getTaskById(id: ID!): Task

    getAllServicePackages(input: PageInput): [ServicePackage!]!
    getServicePackageById(id: ID!): ServicePackage

    getAllQuotes(input: PageInput): [Quote!]!
    getQuoteById(id: ID!): Quote

    getAllInteractions(input: PageInput): [Interaction]!
    getInteractionById(id: ID!): Interaction

    # Deals
    deal(id: ID!): Deal
    deals(pageInput: PageInput, filter: DealFilterInput): [Deal!]!
    dealsByCustomer(customerCompanyId: ID!): [Deal!]!
    dealsByStatus(statuses: [String!]!): [Deal!]!


    #Marketing
    getActivityById(id: ID!): CampaignActivity
    getActivitiesByCampaignId(campaignId: ID!): [CampaignActivity]
    getActivitiesByStatus(status: ActivityStatus!): [CampaignActivity]

    getAttributionById(id: ID!): CampaignAttribution
    getCampaignInteractionById(id: ID!): CampaignInteraction
    getMetricById(id: ID!): CampaignMetric
    getCampaignById(id: ID!): MarketingCampaign
    getSegmentById(id: ID!): CustomerSegment
}


#Mutations
type Mutation {
    # Account Management
    signUp(input: SignUpInput!): AuthResponse!
    login(input: LoginInput!): AuthResponse!
    refreshToken(input: RefreshTokenInput!): AuthResponse!

    # CRM
    createUser(input: UserInput!): User!
    updateUser(id: ID!, input: UserInput!): User!
    deleteUser(id: ID!): Boolean!

    # Customer Company
    createCompany(command: CreateCompanyInput!): CompanyResponse
    updateCompany(command: UpdateCompanyInput!): CompanyResponse
    activateCompany(id: ID!, activationNotes: String): CompanyResponse
    blockCompany(command: BlockCompanyInput!): CompanyResponse
    deactivateCompany(command: DeactivateCompanyInput!): CompanyResponse
    upgradeToEnterprise(command: UpgradeToEnterpriseInput!): CompanyResponse
    signContract(command: SignContractInput!): CompanyResponse
    deleteCompany(id: ID!): Boolean!
    addContactPerson(command: AddContactPersonInput!): CompanyResponse

    # Opportunities
    createOpportunity(input: CreateOpportunityInput!): Opportunity!
    updateOpportunity(input: UpdateOpportunityInput!): Opportunity!
    qualifyOpportunity(opportunityId: ID!): Opportunity!
    moveToProposal(opportunityId: ID!): Opportunity!
    moveToNegotiation(opportunityId: ID!): Opportunity!
    closeOpportunityWon(opportunityId: ID!): Opportunity!
    closeOpportunityLost(opportunityId: ID!): Opportunity!
    reopenOpportunity(opportunityId: ID!): Opportunity!
    deleteOpportunity(opportunityId: ID!): Boolean!


    # Tasks
    createTask(input: TaskInput!): Task!
    updateTask(id: ID!, input: TaskInput!): Task!
    deleteTask(id: ID!): Boolean!

    # Service Package
    createServicePackage(input: ServicePackageInput!): ServicePackage!
    updateServicePackage(id: ID!, input: ServicePackageInput!): ServicePackage!
    deleteServicePackage(id: ID!): Boolean!

    # Quote
    createQuote(input: QuoteInput!): Quote!
    addQuoteItem(id: ID!, input: QuoteItemInput!): Quote!
    deleteQuoteItem(itemId: ID!): Quote!
    deleteQuote(id: ID!): Boolean!

    # Interaction
    createInteraction(input: InteractionInput!): Interaction!
    updateInteraction(id: ID!, input: InteractionInput!): Interaction!
    deleteInteraction(id: ID!): Boolean!

    # Deals
    createDeal(input: CreateDealInput!): Deal!
    signDeal(input: SignDealInput!): Deal!
    markDealAsPaid(dealId: ID!): Deal!
    startDealExecution(dealId: ID!): Deal!
    completeDeal(input: CompleteDealInput!): Deal!
    cancelDeal(dealId: ID!): Deal!
    updateDealServices(input: UpdateDealServicesInput!): Deal!

    # Marketing Campaign
    createActivity(input: CampaignActivityInput!): CampaignActivity
    updateActivity(input: CampaignActivityInput!, id: ID!): CampaignActivity
    deleteActivity(id: ID!): Boolean
    startActivity(id: ID!): CampaignActivity
    completeActivity(id: ID!): CampaignActivity

    # Marketing Mutations
    createCampaignInteraction(input: CampaignInteractionInput!): CampaignInteraction!
    updateCampaignInteraction(id: ID!, input: CampaignInteractionInput!): CampaignInteraction!
    deleteCampaignInteraction(id: ID!): Boolean!

    createAttribution(input: CampaignAttributionInput!): CampaignAttribution!
    updateAttribution(id: ID!, input: CampaignAttributionInput!): CampaignAttribution!
    deleteAttribution(id: ID!): Boolean!

    createMetric(input: CampaignMetricInput!): CampaignMetric!
    updateMetric(id: ID!, input: CampaignMetricInput!): CampaignMetric!
    deleteMetric(id: ID!): Boolean!

    createCampaign(input: MarketingCampaignInput!): MarketingCampaign!
    updateCampaign(id: ID!, input: MarketingCampaignInput!): MarketingCampaign!
    deleteCampaign(id: ID!): Boolean!

    createSegment(input: CustomerSegmentInput!): CustomerSegment!
    updateSegment(id: ID!, input: CustomerSegmentInput!): CustomerSegment!
    deleteSegment(id: ID!): Boolean!
}
